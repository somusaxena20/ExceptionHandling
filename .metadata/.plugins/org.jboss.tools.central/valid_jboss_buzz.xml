<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title>How to categorize C programs by behavior</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/11/15/how-categorize-c-programs-behavior" /><author><name>Martin Sebor</name></author><id>bb47bd70-8885-4eda-b25b-9f30e4c240dc</id><updated>2022-11-15T07:00:00Z</updated><published>2022-11-15T07:00:00Z</published><summary type="html">&lt;p&gt;Most of us who write &lt;a href="https://developers.redhat.com/topics/c"&gt;C and C++&lt;/a&gt; code intuitively understand why some programs might behave differently when compiled with different compilers or different compiler options, or when running under particular conditions. We're also aware of the dangers of undefined behavior and usually try to avoid it in our code. But not all of us appreciate the many useful (and often unavoidable) aspects of undefined behavior. This article explains the kinds of behavior the C standard uses to categorize programs and their subtle, sometimes unexpected, impacts on compilers, libraries, other standards, and programmers themselves.&lt;/p&gt; &lt;p&gt;Programmers are rarely familiar with the subtle nuances of undefined behavior. Nor do programmers pay as close attention to the other kinds of behavior that C programs are subject to, or when that behavior might occur. In our discussions, we often use terms like "valid code" or "correct program" without having a shared understanding of their meanings.&lt;/p&gt; &lt;p&gt;I'm sometimes surprised that not even expert programmers, including C committee members, always agree on what the terms mean. Some don't know why the basic categorizations of program behavior were introduced into C in the first place, or their purpose.&lt;/p&gt; &lt;h2&gt;The standard is a treaty&lt;/h2&gt; &lt;p&gt;A programming language standard outlines two sets of requirements: One that implementations must follow when translating programs, and another that programmers are subject to in order for implementations to fulfill their end of the bargain. In the words of the &lt;a href="http://std.dkuug.dk/jtc1/sc22/wg14/www/charter"&gt;C Charter&lt;/a&gt;: "the standard is a treaty between implementor &lt;em&gt;(sic)&lt;/em&gt; and programmer."&lt;/p&gt; &lt;p&gt;The standard details the rules and defines the outcomes when both sides play by those rules. However, it does not and cannot define what happens when either side steps outside those rules.&lt;/p&gt; &lt;p&gt;That distinction seems straightforward. Yet, for historical reasons, details of the C standard are a bit more nuanced, and reality makes them more complicated still. The next section of this article explains how the C standard categorizes programs, depending on the extent to which they follow the rules. I'll explain why these mechanisms were introduced, and what programmers should expect of programs that fall under the different categories.&lt;/p&gt; &lt;h2&gt;Categories of programs by behavior&lt;/h2&gt; &lt;p&gt;The original goal of the C standard committee in the early 1980s was to codify the set of rules in existing implementations. This standardization was possible for features in the original &lt;a href="https://github.com/auspbro/ebook-c/blob/master/The.C.Programming.Language.2Nd.Ed%20Prentice.Hall.Brian.W.Kernighan.and.Dennis.M.Ritchie..pdf"&gt;Kernighan and Ritchie C manual&lt;/a&gt; where compilers and runtime libraries all agreed on their interpretation, but became more difficult when the compilers and libraries diverged from it. Some diverged because the manual was ambiguous, others to provide extensions useful for their target environment or CPU.&lt;/p&gt; &lt;p&gt;The committee was cautious to minimize disruption, both to existing implementations and to the large body of C code out there. But the committee did not want to diminish the value of conformance. Therefore, the committee introduced the notion of &lt;em&gt;degrees of conformance.&lt;/em&gt; Although all implementations must conform to the standard, programs can choose to conform to varying degrees, and with varying guarantees for code portability.&lt;/p&gt; &lt;p&gt;To that end, the C standard recognizes several categories of programs. Each category in turn places progressively weaker requirements on implementations, and, as a result, weaker guarantees about programs' behavior and portability.&lt;/p&gt; &lt;p&gt;Before going into the details, a few words on terminology:&lt;/p&gt; &lt;ul&gt;&lt;li&gt; &lt;p&gt;An &lt;em&gt;implementation&lt;/em&gt; consists of a compiler and the standard C library. The C library rarely stands on its own but is usually incorporated into a larger library that implements some superset of C such as POSIX, or some proprietary operating system API.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;By &lt;em&gt;behavior&lt;/em&gt;, the standard means the observable output of a program: The data it writes to open streams (such as stdout and stderr), or the accesses it performs on volatile storage (both reading from it and writing to it).&lt;/p&gt; &lt;p&gt;Formally, the term &lt;em&gt;behavior&lt;/em&gt; is defined as &lt;em&gt;external appearance or action&lt;/em&gt;. It's important to understand that this doesn't include the behavior that might be observed in a debugger, such as changing values of variables while stepping through a function, or in the output of a tracing tool attached to the program by some sort of an interprocess communication mechanism.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Finally, the term &lt;em&gt;portability&lt;/em&gt; is defined in the ISO vocabulary as the &lt;em&gt;capability of a program to be executed on various types of data processing systems without converting the program to a different language and with little or no modification&lt;/em&gt;.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;p&gt;Although the term &lt;em&gt;behavior&lt;/em&gt; is frequently used to describe the effects of a single coding construct, such as a subtraction expression or a call to a library function like &lt;code&gt;strlen&lt;/code&gt;, the implications of a construct can extend to the entire program. This is an important and often misunderstood point: The consequences of a single coding construct have an impact not just on the constructs that follow but sometimes also (and perhaps unintuitively) constructs that come before it in the program source. I'll have more to say about this topic in the &lt;a href="#undefined_behavior"&gt;section on undefined behavior&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;It's also important to understand that the categories described in this article exist solely for the purpose of, and within the context of, the C standard. The same program doesn't fall under one category when compiled with compiler A or running on operating system X and under a different category when compiled with B or running on Y. Conversely, the writers of A or X don't get to decide what category a class of programs might fall into when targeting A and X, while those of B and Y get to make a different choice for their implementation. The categorization of a program is completely determined by the requirements of the C standard, even though implementers may, and often do, provide stronger guarantees about program behavior.&lt;/p&gt; &lt;p&gt;The same is true for other specifications that incorporate C, such as POSIX. The difference with the other specifications is that by doing so, implementers as noted do not change the categorization of C programs, while the authors of other specifications tend to "override" it for their own purposes. As a result, a program that falls into one category in C might fall into a different category under POSIX—a category with stronger guarantees than the C category. (The converse isn't possible without conflicting with it.)&lt;/p&gt; &lt;h3 id="well_defined_behavior"&gt;Well-defined behavior&lt;/h3&gt; &lt;p&gt;Ideally, a program is portable without change, not just to the environments intended for it, but to all possible environments, whether or not they exist in the wild, ever did, or might in the future. Given the same input, a portable program runs with the same output everywhere it's compiled today, and will continue to do so in the future. Another way we can describe a portable program like this is to call it &lt;em&gt;well-defined.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Because the fundamental purpose of a standard is to foster portability, the prime goal of the C standard is to describe the behavior of portable programs. The behavior of all other categories is a secondary concern.&lt;/p&gt; &lt;p&gt;Portable programs provide the strongest guarantees to their users. To ensure these guarantees, portable programs must:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Consist only of code with well-defined syntax and rely only on constructs with well-defined semantics.&lt;/li&gt; &lt;li&gt;Adhere to all the most stringent requirements of the C standard, and therefore: &lt;ul&gt;&lt;li&gt;Either make no unconditional uses of any &lt;a href="#optional_features"&gt;optional features&lt;/a&gt; specified by the standard, or guard the use of each feature by the appropriate &lt;code&gt;__STDC_&lt;em&gt;XXX&lt;/em&gt;__&lt;/code&gt; feature test macro.&lt;/li&gt; &lt;li&gt;Use no &lt;a href="#implementation_extensions"&gt;implementation extensions&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;Stay within all minimum implementation limits specified by the standard.&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; &lt;/ul&gt;&lt;h3&gt;Unspecified behavior&lt;/h3&gt; &lt;p&gt;The standard describes a few dozen coding constructs that might result in more than one kind of behavior (Annex J.1 lists 63 distinct cases). A couple of examples are whether the same string literals have distinct addresses, or the order in which subexpressions are evaluated. Uses of these constructs are valid code that implementations might handle in different ways that can even change from one instance to another. Because the identified constructs are valid code, their handling doesn't extend to issuing an error, either during compilation or at runtime.&lt;/p&gt; &lt;p&gt;A program with unspecified behavior is a program that is correct according to the standard, but that contains one or more coding constructs with unspecified behavior. Such a program must run successfully on every implementation (i.e., it must not crash—or &lt;em&gt;trap,&lt;/em&gt; in the parlance of the standard—or otherwise misbehave), but could have different output from one execution to another.&lt;/p&gt; &lt;p&gt;For example, the behavior (specifically the result) of the following program is unspecified. It might return either 0 or 1, depending on whether or not the compiler merges the two empty strings into a single instance:&lt;/p&gt; &lt;pre&gt; &lt;code class="cpp"&gt;int main (void) { const char *s = ""; return s == ""; }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In theory, the program could also return 0 the first time it runs and 1 the second time, although in practice that's very unlikely.&lt;/p&gt; &lt;p&gt;Not every program that contains a coding construct with unspecified behavior necessarily has unspecified behavior itself. Programs have unspecified behavior only when their output depends in an observable way on the unspecified effects of the construct.&lt;/p&gt; &lt;h3&gt;Implementation-defined behavior&lt;/h3&gt; &lt;p&gt;Besides constructs with undefined behavior, the standard also describes a number of others that might result in more than one observable behavior, but where implementations are required to document how each instance is handled. Annex J.3 contains an exhaustive list of the 127 instances of implementation-defined behavior in C.&lt;/p&gt; &lt;p&gt;It should be emphasized that, just like the programs with unspecified behavior that we discussed in the previous section, a program with implementation-defined behavior is a valid program that must run successfully. It must not crash or otherwise misbehave.&lt;/p&gt; &lt;p&gt;This category is less useful than it seems. First, simply because a construct's behavior is documented doesn't make the construct portable, so relying on it doesn't improve the portability of a program. And second, not all implementations follow the requirement to document their choices.&lt;/p&gt; &lt;h3 id="locale_defined_behavior"&gt;Locale-specific behavior&lt;/h3&gt; &lt;p&gt;&lt;em&gt;Locale-specific behavior&lt;/em&gt; is behavior that arises when a program runs in a locale other than the default C locale. An example locale is &lt;code&gt;fr_CA&lt;/code&gt; for Canadian French. This behavior is a special category that C programs opt into, either by being translated in a specific locale, or at runtime by calling the &lt;code&gt;setlocale&lt;/code&gt; function with a first argument other than &lt;code&gt;"C"&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Implementations are expected to document the behavior of programs in specific locales. We will not consider this category further; it's effectively a special case of well-defined behavior where the output of a program can change from one environment (locale) to another.&lt;/p&gt; &lt;h3 id="undefined_behavior"&gt;Undefined behavior&lt;/h3&gt; &lt;p&gt;Programs that don't fit in any of the categories discussed so far are &lt;em&gt;undefined.&lt;/em&gt; Annex J.2 - Undefined behavior lists over 200 instances of such behavior. However, unlike the lists in the appendices of unspecified and implementation-defined behavior, Annex J.2's list is not exhaustive. This is sometimes a source of misunderstanding that is worth clearing up. Annex J.2 enumerates &lt;em&gt;only&lt;/em&gt; the instances explicitly called out in the main body of the text. Beyond those instances where the C standard explicitly makes the behavior of a construct undefined, there are many others where the standard doesn't specify the behavior under some conditions. These instances use the words &lt;em&gt;shall&lt;/em&gt; or &lt;em&gt;shall not&lt;/em&gt; to outline a requirement on programs, and don't typically appear in the annex.&lt;/p&gt; &lt;p&gt;When interpreting the standard, it's important to be aware of this caveat. Don't assume that a programming construct always works the way it's working on your current implementation, just because the construct isn't explicitly listed as undefined.&lt;/p&gt; &lt;p&gt;The C standard describes programs that contain an undefined construct as either &lt;em&gt;nonportable&lt;/em&gt; or &lt;em&gt;erroneous&lt;/em&gt;. The practical difference is that nonportable programs run correctly (don't crash or misbehave), perhaps even with the expected output, in some environments. In contrast, erroneous programs might (although they don't need to) behave erratically or crash.&lt;/p&gt; &lt;p&gt;Most real-world programs fall into the undefined category: They contain some code whose behavior is not defined by the C standard. This isn't necessarily a bad thing. The behavior may be defined by some other standard or provided as an extension of the implementation targeted by the program's authors.&lt;/p&gt; &lt;p&gt;However, these assurances don't change the categorization of the program as undefined under the rules of the C standard. The behavior may also seem to be defined by a given implementation, in the sense that the construct and the program behave as the programmer intended. But unless the implementation documents as an extension the behavior of the construct under the conditions the standard doesn't specify, it should be considered erroneous.&lt;/p&gt; &lt;p&gt;In practice, not all implementations document all their extensions. Such practices create a fertile source of subtle portability bugs, as working programs start to misbehave after a trivial upgrade of the compiler or libraries.&lt;/p&gt; &lt;p&gt;Undefined behavior can be broken down into two kinds: &lt;em&gt;compile-time&lt;/em&gt; undefined behavior and &lt;em&gt;runtime&lt;/em&gt; undefined behavior. We'll consider each category in turn.&lt;/p&gt; &lt;h4&gt;Compile-time undefined behavior&lt;/h4&gt; &lt;p&gt;&lt;em&gt;Compile-time undefined behavior&lt;/em&gt; refers to the behavior of constructs that are processed during translation, such as preprocessing directives or the evaluation of constant expressions. An example of nonportable compile-time undefined behavior is the use of an implementation-specific literal, such as a &lt;a href="https://gcc.gnu.org/onlinedocs/gcc-12.1.0/gcc/Binary-constants.html"&gt;binary constant&lt;/a&gt; like &lt;code&gt;0b101010&lt;/code&gt; with GCC (prior to C23). An example of erroneous compile-time undefined behavior (in popular compilers like Clang and GCC) is the following definition:&lt;/p&gt; &lt;pre&gt; &lt;code class="cpp"&gt;enum { e, f, g = f / e };&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The semantics of the division expression are undefined when the second operand is zero. Because the compiler evaluates this division expression to process the definition of the enumeration, the problem occurs at compile time.&lt;/p&gt; &lt;p&gt;High-quality implementations diagnose erroneous compile-time undefined behavior by issuing an error message and rejecting the program. Other implementations might evaluate the division to zero, possibly as a deliberate extension, or as an incidental outcome of the coding path taken in the compiler. The example on &lt;a href="https://godbolt.org/z/oW6coq5fv"&gt;Godbolt's Compiler Explorer&lt;/a&gt; illustrates these two alternatives in popular compilers.&lt;/p&gt; &lt;p&gt;But the possibilities don't end there. Low-quality implementations might silently accept the code but emit a program that behaves erratically at runtime: It might abort or produce inaccurate output. And in other implementations, the construct might even cause the compiler itself to crash.&lt;/p&gt; &lt;p&gt;In summary, a program that contains a coding construct with compile-time undefined behavior is undefined regardless of whether the program depends on that construct in any way. And the ill effects extend beyond the program to the implementation itself. With such a compiler, conspiracy theorists would be vindicated for believing that even just compiling an undefined program might wipe out one's hard drive.&lt;/p&gt; &lt;h4&gt;Runtime undefined behavior&lt;/h4&gt; &lt;p&gt;&lt;em&gt;Runtime undefined behavior&lt;/em&gt;, on the other hand, refers to the outcome of a construct during program execution. An example of nonportable runtime undefined behavior that's pervasive in almost all programs is calling a library function that's defined neither in the program nor by the C standard, such POSIX &lt;a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html"&gt;popen&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Another example of runtime undefined behavior is calling the C standard &lt;code&gt;printf&lt;/code&gt; function with a format directive whose behavior is undefined in the C standard but defined by some other standard such as POSIX. An example is &lt;code&gt;%2$d:%1$d&lt;/code&gt;, used by POSIX to reorder the subsequent arguments in the output. Similar examples involve calling nonstandard functions that are either provided as intrinsics by the compiler or defined by the target system.&lt;/p&gt; &lt;p&gt;The most important difference from compile-time undefined behavior is that a program that contains a coding construct with runtime undefined behavior is itself undefined only if the construct is reached during the program's execution. However, if the construct is reached (or can be proven to be reached during program analysis), the effects of undefined runtime behavior can manifest at any point in the execution of the program. The effects can appear even before execution reaches the construct.&lt;/p&gt; &lt;p&gt;The pervasive reach of runtime constructs with undefined behavior is quite unintuitive, so much so that it has been colloquially referred to as &lt;em&gt;undefined behavior time travel&lt;/em&gt;. The basic reason for this phenomenon is that the standard deliberately allows implementations to execute code out of order, including in parallel. Therefore, statements with no observable side effects that don't depend on each other can be reordered, or even merged with others, for greater efficiency.&lt;/p&gt; &lt;p&gt;Another important difference from compile-time undefined behavior is the ways high-quality implementations respond to an erroneous instance when they detect it: Although they can issue a warning message (many do for a small subset of undefined constructs), the standard prohibits conforming compilers from rejecting the program unless they can prove that &lt;em&gt;every&lt;/em&gt; execution of the program is undefined.&lt;/p&gt; &lt;p&gt;In typical scenarios, this restriction virtually rules out such a response for separately compiled programs that consist of multiple translation units. Although it's common to promote warnings to errors through options like &lt;code&gt;-Werror&lt;/code&gt;, doing so must be left at the discretion of the user, because it goes against the requirement of the standard and thus renders the implementation not conforming.&lt;/p&gt; &lt;h2 id="optional_features"&gt;Optional features&lt;/h2&gt; &lt;p&gt;Starting with C99, the standard has introduced features that conforming implementations are not required to provide. In most cases, for better portability, the presence of the support can be tested with a preprocessor conditional.&lt;/p&gt; &lt;p&gt;For example, support for variably modified types, an optional feature, can be checked by testing the value of the &lt;code&gt;__STDC_NO_VLA__&lt;/code&gt; macro. The value 1 means that the feature is supported, and any other value means it's not.&lt;/p&gt; &lt;p&gt;Relying on an optional feature is well-defined, but doing so without an equivalent backup (obviously) degrades the portability of the program to implementations that do not support the feature.&lt;/p&gt; &lt;h2 id="implementation_extensions"&gt;Implementation extensions&lt;/h2&gt; &lt;p&gt;Virtually all implementations of C and C++ provide features that are not specified by the C standard at all. Most hosted environments don't implement the C standard alone, but also some superset of it, such as POSIX or some proprietary layer. Similarly, most compilers support other specifications that are supersets of C or extend C's capabilities, such as OpenMP. Many implementations also provide additional functions and capabilities that are not specified by any standard.&lt;/p&gt; &lt;p&gt;Extensions do not affect the conformance of the implementation, as long as they have no impact on the behavior of strictly conforming programs (discussed next). Implementations are required to document their extensions.&lt;/p&gt; &lt;h2&gt;Strictly conforming and conforming programs&lt;/h2&gt; &lt;p&gt;Programs whose behavior depends exclusively on portable code are termed &lt;em&gt;strictly conforming&lt;/em&gt; in the C standard. As discussed in the &lt;a href="#well_defined_behavior"&gt;section on well-defined behavior&lt;/a&gt;, such programs must not rely on any unspecified or implementation-defined constructs, use any implementation extensions, or use optional C features without a corresponding preprocessor guard. Strictly conforming programs can, however, invoke &lt;a href="#locale_defined_behavior"&gt;locale-specific behavior&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Other programs that are accepted (the standard uses the word &lt;em&gt;acceptable&lt;/em&gt;) by at least one conforming implementation are simply called &lt;em&gt;conforming&lt;/em&gt;. Conforming programs might contain code with unspecified, implementation-defined, and even undefined behavior, including syntactic extensions such as lexical tokens and additional keywords.&lt;/p&gt; &lt;p&gt;It's worth taking a minute to clarify what the standard means by acceptable: It means not only that an implementation successfully compiles the program (with or without warnings), but also that the program runs successfully to completion, and that it doesn't do so simply by accident. If it contains undefined code, it must be only nonportable code whose semantics are documented by the implementation, not code with erroneous undefined behavior (i.e., code whose semantics are not documented, even if they happen to be benign and perfectly reasonable).&lt;/p&gt; &lt;p&gt;It's important to emphasize that, although strictly conforming programs must not contain code with undefined behavior, they can contain constructs with unspecified or implementation-defined behavior. However, those that do so must avoid relying on such behavior.&lt;/p&gt; &lt;p&gt;This distinction might seem like playing word games, but it's valid and important. Remember, even the most portable programs usually contain unspecified behavior. Here's an example that's not unusual in production code:&lt;/p&gt; &lt;pre&gt; &lt;code class="cpp"&gt;int main (void) { int i = 0, j = 0; return (++i - ++j); }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The order in which the two subexpressions in (&lt;code&gt;++i&lt;/code&gt; and &lt;code&gt;++j&lt;/code&gt;) are evaluated is unspecified. But because they are both evaluated before the subtraction, the result of the program is zero regardless. Thus, this program doesn't depend on the unspecified behavior, and so the program is strictly conforming: It's portable to and will run with the same output in all hosted environments.&lt;/p&gt; &lt;p&gt;The same argument would apply if the operand of the return statement were just &lt;code&gt;1 - 1&lt;/code&gt;. Even constant operands are evaluated, and the order of their evaluation is also unspecified.&lt;/p&gt; &lt;h2&gt;Practical implications&lt;/h2&gt; &lt;p&gt;So what are the practical implications of all this, that we as programmers (as opposed to the C committee, or compliance engineers) might care about?&lt;/p&gt; &lt;p&gt;The categories of behavior establish a common framework for reasoning about program &lt;em&gt;correctness&lt;/em&gt;. Our number-one priority is to write correct programs, so it's rather important to have a solid, shared definition of what &lt;em&gt;correct&lt;/em&gt; means.&lt;/p&gt; &lt;p&gt;Setting aside design requirements (those are unavoidably outside the scope of this discussion) and focusing strictly on coding, a &lt;em&gt;correct program&lt;/em&gt; is a &lt;em&gt;conforming program&lt;/em&gt; that's &lt;em&gt;acceptable&lt;/em&gt; to the implementations we target.&lt;/p&gt; &lt;p&gt;With that definition in mind, deciding whether a program is correct should be easy as long as the implementations we target are conforming (including the requirement to document extensions). If all code in our program is defined either by the C standard (including unspecified behavior), or in the manuals that come with the compiler and libraries we depend on, it's correct.&lt;/p&gt; &lt;p&gt;In contrast, if our program contains code whose semantics aren't defined anywhere (i.e., nowhere in the manuals for our implementation or the rest of the system), it is, in the parlance of the C standard, erroneous. In common speech, it's buggy, and it doesn't matter whether the bug manifests itself in an observable way or is latent.&lt;/p&gt; &lt;p&gt;A corollary of this definition is that using an implementation that doesn't document some of the implementation-defined behavior or some of its extensions prevents us from relying on those features if we want correct programs. If using them cannot be avoided, we either need to accept that our programs are erroneous, or we need to redefine what correctness means to us. The latter course of action obviously presents problems when discussing our expectations with others—notably implementers, who rely on the standard definition of correctness.&lt;/p&gt; &lt;h2&gt;References&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="https://www.iso.org/standard/74528.html"&gt;ISO/IEC 9899:2018 Information technology — Programming languages — C&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf"&gt;Rationale for International Standard — Programming Languages — C, Revision 5.10&lt;/a&gt;, April 2003&lt;/li&gt; &lt;li&gt;&lt;a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2611.htm"&gt;Programming Language C — C23 Charter&lt;/a&gt;, David Keaton&lt;/li&gt; &lt;li&gt;&lt;a href="https://www.iso.org/standard/63598.html"&gt;ISO/IEC 2382:2015 Information technology — Vocabulary&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.knosof.co.uk/cbook/cbook.html"&gt;The New C Standard — An Economic and Cultural Commentary&lt;/a&gt;, Derek M. Jones&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/11/15/how-categorize-c-programs-behavior" title="How to categorize C programs by behavior"&gt;How to categorize C programs by behavior&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Martin Sebor</dc:creator><dc:date>2022-11-15T07:00:00Z</dc:date></entry><entry><title type="html">gRPC made easy with Quarkus</title><link rel="alternate" href="http://www.mastertheboss.com/soa-cloud/quarkus/grpc-made-easy-with-quarkus/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/soa-cloud/quarkus/grpc-made-easy-with-quarkus/</id><updated>2022-11-14T19:06:50Z</updated><content type="html">This article discusses how to create applications with the gRPC framework and Quarkus. We will reuse the sample Service definition from first Java gRPC application and run it as Quarkus REST application. Defining the gRPC Service Firstly, we recommend reading this article for an introduction to the gRPC framework: Getting started with gRPC on Java ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">KOGITO 1.30.0 RELEASED!</title><link rel="alternate" href="https://blog.kie.org/2022/11/kogito-1-30-0-released.html" /><author><name>Tiago Dolphine</name></author><id>https://blog.kie.org/2022/11/kogito-1-30-0-released.html</id><updated>2022-11-14T11:10:16Z</updated><content type="html">We are glad to announce that the Kogito 1.30.0 release is now available! This goes hand in hand with , release. From a feature point of view, we have included a series of new features and bug fixes, including: * Event State timeout * Allow specifying different event marshallers per channel * Start event is not behaving as expected when exclusive is false * New Avro marshallers/unmarshallers addon * Build SWF examples images with Jib * Group all Jobs service JDBC flavors on one container image * Verify that Kaniko is able to push on Kubernetes internal registry * Deprecate Github Showcase Example * Serverless Operator: Setup Nightly pipeline * Update quarkus-openapi-generator to 0.12.0 For more details head to the complete . All artifacts are available now: * Kogito runtime artifacts are available on Maven Central. * Kogito examples can be found. * Kogito images are available on. * Kogito operator is available in the in OpenShift and Kubernetes. * Kogito tooling 0.25.0 artifacts are available at the. A detailed changelog for 1.30.0 can be found in . New to Kogito? Check out our website . Click the "Get Started" button. The post appeared first on .</content><dc:creator>Tiago Dolphine</dc:creator></entry><entry><title>3 ways to embed a commit hash in Go programs</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/11/14/3-ways-embed-commit-hash-go-programs" /><author><name>Panagiotis Georgiadis</name></author><id>f2546d72-10b9-4d83-a762-cf5c44656bf6</id><updated>2022-11-14T07:00:00Z</updated><published>2022-11-14T07:00:00Z</published><summary type="html">&lt;p&gt;Whether you are using &lt;a href="https://developers.redhat.com/topics/go"&gt;Go&lt;/a&gt; to write a simple console-based utility or a fancy web application, it is always helpful to reference the previous version of your software. This information is essential, especially for developers. They need to know what the source code looked like in previous versions, so they can debug any issues introduced at specific points in time.&lt;/p&gt; &lt;p&gt;To do that, you need a &lt;em&gt;system&lt;/em&gt; that can &lt;em&gt;control&lt;/em&gt; and manage different &lt;em&gt;versions&lt;/em&gt; of the source code, such as &lt;a href="https://git-scm.com/"&gt;git&lt;/a&gt;. Whenever you want to capture a snapshot of the program's current codebase, you run a &lt;code&gt;git commit&lt;/code&gt; command that saves the code at that point in time. To make sure you do not overwrite a previously saved record, &lt;code&gt;git&lt;/code&gt; creates (by default) a unique identifier, hashed with the SHA-1 algorithm, for every &lt;code&gt;commit&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Usually, when a decent amount of progress has been made, a couple of features have been implemented and lots of bugs have been fixed, it's about time to make things official and announce a new release version of your software. Of course, embedding the release version is not new. You most likely already have automation in place to provide this information within your software (e.g., during the release pipeline). But this kind of progress doesn't happen in a day. So what happens in the meantime? You do what the rolling-release model does, associating every build (&lt;code&gt;go build&lt;/code&gt;) with a snapshot of the code at that point in time. This is when the &lt;code&gt;git commit&lt;/code&gt; hash comes in handy. There are three ways to embed this hash into your Go program.&lt;/p&gt; &lt;h2&gt;1. Using -ldflags&lt;/h2&gt; &lt;p&gt;The most common way is by using a &lt;code&gt;string&lt;/code&gt; variable, a value populated at build time via flags.&lt;/p&gt; &lt;p&gt;For example:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-cpp"&gt;var Commit string&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;go build -ldflags="-X main.Commit=$(git rev-parse HEAD)"&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The disadvantage here is that you need to remember this syntax and run it every time you build your code. You can make this easier by using &lt;code&gt;Makefiles&lt;/code&gt; to do that for you.&lt;/p&gt; &lt;h2&gt;2. Using go generate&lt;/h2&gt; &lt;p&gt;Another way is to use a file (let's call it &lt;code&gt;VERSION.txt&lt;/code&gt;). This process requires the installation of Go 1.16 or later, since it uses &lt;code&gt;go:generate&lt;/code&gt; to populate the file contents and &lt;code&gt;go:embed&lt;/code&gt; to populate the variable. For example:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-cpp"&gt;//go:generate sh -c "printf %s $(git rev-parse HEAD) &gt; VERSION.txt" //go:embed VERSION.txt var Commit string&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You have to remember to run &lt;code&gt;go generate&lt;/code&gt; every time before &lt;code&gt;go build&lt;/code&gt;. To avoid developing an unnecessary memory muscle, you can put this block into your &lt;code&gt;Makefile&lt;/code&gt;, which is part of the &lt;code&gt;@build&lt;/code&gt; target.&lt;/p&gt; &lt;p&gt;With this method, you have a file (&lt;code&gt;VERSION.txt&lt;/code&gt;) that always captures the &lt;em&gt;latest&lt;/em&gt; &lt;code&gt;commit hash&lt;/code&gt; of the repository. While this information is not &lt;em&gt;that&lt;/em&gt; useful information for you (since you can also see this information in GitHub's user interface or just using &lt;code&gt;git&lt;/code&gt;), the advantage here is that you can use this file for other things in your &lt;a href="https://developers.redhat.com/topics/ci-cd"&gt;CI/CD&lt;/a&gt; environment as well. If a component needs to know the version, now it has an easy way to find it: by reading this file.&lt;/p&gt; &lt;p&gt;However, the downside here is that you have to remember to include that file as part of your code well. This is something that is generated by the computer and not written by a person, so it's not uncommon for people to forget about it.&lt;/p&gt; &lt;p&gt;This way is mostly preferred when you are officially releasing a new stable version of your software, but not every time your merge a PR. Although I can see the benefits, I wouldn't recommend this for daily use.&lt;/p&gt; &lt;h2&gt;3. Using runtime/debug package&lt;/h2&gt; &lt;p&gt;The third solution to this problem is quite simple and comes fresh from the &lt;a href="https://pkg.go.dev/runtime/debug"&gt;&lt;u&gt;runtime/debug package&lt;/u&gt;&lt;/a&gt;, which is already part of the official Go library.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-cpp"&gt;import "runtime/debug" var Commit = func() string { if info, ok := debug.ReadBuildInfo(); ok { for _, setting := range info.Settings { if setting.Key == "vcs.revision" { return setting.Value } } } return "" }()&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Apart from &lt;code&gt;vsc.revision&lt;/code&gt;, you can also query for &lt;code&gt;vcs.time&lt;/code&gt; (that is the &lt;code&gt;timestamp&lt;/code&gt; of the commit message) and check &lt;code&gt;vcs.modified&lt;/code&gt; (that is &lt;code&gt;true&lt;/code&gt; if the binary builds from &lt;em&gt;uncommitted&lt;/em&gt; changes). To make this work, you need Go 1.18, and should build using the &lt;code&gt;-buildvcs&lt;/code&gt; (which should be available in your &lt;code&gt;goenv&lt;/code&gt;).&lt;/p&gt; &lt;p&gt;This is a great way to include the commit hash information without having to take care of building with a specific set of &lt;code&gt;ldflags&lt;/code&gt; or running &lt;code&gt;go generate&lt;/code&gt; every single time. As long as you have Go 1.18 or higher, a simple &lt;code&gt;go build&lt;/code&gt; should suffice to pass the git information into the &lt;code&gt;Commit string&lt;/code&gt; variable.&lt;/p&gt; &lt;h2&gt;What's the best way to embed a commit hash?&lt;/h2&gt; &lt;p&gt;You might ask: Which of the three ways is the best? The answer is that you should pick the one that fits your needs. You might not need any of these methods, or you might use more than one in combination.&lt;/p&gt; &lt;p&gt;Personally, I like the last way, because I don't need a &lt;code&gt;Makefile&lt;/code&gt; and I don't want to remember to do anything extra out of the ordinary. So, if the usual &lt;code&gt;go build&lt;/code&gt; gives me all I need, then that's enough for me. Less is more!&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/11/14/3-ways-embed-commit-hash-go-programs" title="3 ways to embed a commit hash in Go programs"&gt;3 ways to embed a commit hash in Go programs&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Panagiotis Georgiadis</dc:creator><dc:date>2022-11-14T07:00:00Z</dc:date></entry><entry><title type="html">Vlog: Git Tips on Upstream Repositories and Merge Conflicts</title><link rel="alternate" href="https://www.youtube.com/watch?v=v5d6x3kT7lU" /><author><name>Cameron Rodriguez</name></author><id>https://www.youtube.com/watch?v=v5d6x3kT7lU</id><updated>2022-11-14T00:00:00Z</updated><dc:creator>Cameron Rodriguez</dc:creator></entry><entry><title type="html">Getting started with gRPC on Java</title><link rel="alternate" href="http://www.mastertheboss.com/java/getting-started-with-grpc-on-java/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/java/getting-started-with-grpc-on-java/</id><updated>2022-11-10T17:08:15Z</updated><content type="html">This article is an introduction to gRPC framework which allows to connect services across data centers using high performance Remote Procedure Calls (RPC). To learn the building blocks of this framework, we will show how to create and test your first gRPC application in Java. Overview of gRPC Firstly, some basic concepts: in gRPC, a ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>Set up an OpenShift cluster to deploy an application in odo CLI</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/11/10/set-openshift-cluster-deploy-application-odo-cli" /><author><name>Francesco Ilario</name></author><id>99cd9947-0cf8-487c-9e3d-9cf898d48fcb</id><updated>2022-11-10T07:00:00Z</updated><published>2022-11-10T07:00:00Z</published><summary type="html">&lt;p&gt;Binding is the task of finding a backing service and connecting it to an application, such as a database. There are several ways to bind applications to cloud services in &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt; and &lt;a href="https://developers.redhat.com/openshift"&gt;Red Hat OpenShift&lt;/a&gt;. The &lt;a href="https://odo.dev/"&gt;odo&lt;/a&gt; command-line interface (CLI) consolidates steps that developers normally have to perform manually, and abstracts away Kubernetes and OpenShift background concepts.&lt;/p&gt; &lt;p&gt;With &lt;code&gt;odo&lt;/code&gt;, you can concentrate on creating applications instead of administering the cluster. The &lt;code&gt;odo&lt;/code&gt; tool automates deployment configurations, build configurations, service routes, and other Kubernetes and OpenShift elements.&lt;/p&gt; &lt;p&gt;The Service Binding Operator, employed by &lt;code&gt;odo&lt;/code&gt;, makes the application developer's life a lot easier by providing a consistent and declarative Service Binding method.&lt;/p&gt; &lt;p&gt;This two-part series demonstrates how to use &lt;code&gt;odo&lt;/code&gt; to create an application and a database service, bind the application to the database using the Service Binding Operator, and get access to the application's REST API. This article prepares the environment with the necessary tools. In part 2, &lt;a href="https://developers.redhat.com/articles/2022/08/11/how-install-and-bind-mongodb-and-rest-application"&gt;Implementation of RestAPI application with MongoDB using SBO&lt;/a&gt;, we will install MongoDB and the application, and bind them together.&lt;/p&gt; &lt;h2&gt;A REST application example&lt;/h2&gt; &lt;p&gt;We will use a REST application written in Go as an example here. The application connects to a MongoDB database using the Service Binding Operator and allows you to manage entries in the database. Data consists of place names and descriptions. The REST API's endpoints allow you to add details to the MongoDB instance and perform create, read, update, and delete (CRUD) operations.&lt;/p&gt; &lt;p&gt;When you request a binding, the Service Binding Operator looks at the data stored within the custom resource (CR) and its corresponding custom resource definition (CRD) inside the service. This data contains the parameters required to bind the application to the service. The Service Binding Operator then projects this binding data into the application's workload resources as environment variables or files. To learn more about the Service Binding Operator and its integration with other products, refer to the &lt;a href="https://redhat-developer.github.io/service-binding-operator/userguide/intro.html"&gt;Service Binding documentation&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Prerequisites&lt;/h2&gt; &lt;p&gt;To run and interact with the application, you must complete the following procedures successfully:&lt;/p&gt; &lt;ol&gt;&lt;li&gt;Install Go and &lt;code&gt;odo&lt;/code&gt; packages&lt;/li&gt; &lt;li&gt;Set up an OpenShift cluster with administrator access&lt;/li&gt; &lt;li&gt;Install the Percona Distribution for MongoDB Operator&lt;/li&gt; &lt;li&gt;Install the Service Binding Operator&lt;/li&gt; &lt;/ol&gt;&lt;p&gt;We will use the following versions of these tools to showcase the application:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Go 1.18.7&lt;/li&gt; &lt;li&gt;odo v3.0.0&lt;/li&gt; &lt;li&gt;OpenShift 4.11&lt;/li&gt; &lt;li&gt;Percona Distribution for MongoDB Operator 1.13.0, provided by &lt;a href="https://www.percona.com"&gt;Percona&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;The following steps provide instructions for each prerequisite.&lt;/p&gt; &lt;h2&gt;Step 1: Install Go and odo packages&lt;/h2&gt; &lt;div&gt; &lt;div&gt;&lt;span&gt;Install Go following the &lt;a href="https://go.dev/doc/install"&gt;official guidelines&lt;/a&gt;.&lt;/span&gt;&lt;/div&gt;   &lt;div&gt;&lt;span&gt;The odo installation process is as simple as downloading the binary for your OS/ARCH and placing it into a folder referenced by your PATH environment variable. In the following you find the installation procedure for Linux/amd64 and odo-v3.0.0. For a different OS or architecture, check the &lt;/span&gt;&lt;a href="https://odo.dev/docs/overview/installation"&gt;&lt;span&gt;odo Installation page&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/div&gt; &lt;div&gt; &lt;/div&gt; &lt;/div&gt; &lt;ol&gt;&lt;li&gt; &lt;p&gt;Download the latest release from the mirror site&lt;/p&gt; &lt;pre&gt; &lt;code&gt;$ curl -L https://developers.redhat.com/content-gateway/rest/mirror/pub/openshift-v4/clients/odo/v3.0.0/odo-linux-amd64 -o odo % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0 100 66.7M 100 66.7M 0 0 3261k 0 0:00:20 0:00:20 --:--:-- 3729k&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Install &lt;code&gt;odo&lt;/code&gt;,&lt;span&gt; you might have to provide your password for root access&lt;/span&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;$ sudo install -o root -g root -m 0755 odo /usr/local/bin/odo [sudo] password for user:&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If you are not allowed to use &lt;code&gt;sudo&lt;/code&gt; or you prefer a rootless installation, you can install the &lt;code&gt;odo&lt;/code&gt; tool to a local folder, like for example &lt;code&gt;~/.local/bin&lt;/code&gt;, and configure your shell:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ mkdir -p ~/.local/bin $ mv odo ~/.local/bin $ export PATH=${HOME}/.local/bin/odo:${PATH} &lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Verify that &lt;code&gt;odo&lt;/code&gt; is installed:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;$ odo version odo v3.0.0 (8694f1946)&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;/ol&gt;&lt;h2&gt;Step 2: Set up an OpenShift cluster&lt;/h2&gt; &lt;div&gt; &lt;div&gt;&lt;span&gt;There are several ways to use OpenShift, like using &lt;/span&gt;&lt;a href="https://github.com/code-ready/crc"&gt;&lt;span&gt;crc&lt;/span&gt;&lt;/a&gt;&lt;span&gt; or running a managed cluster. You can find more details in the &lt;a href="https://developers.redhat.com/products/openshift/getting-started"&gt;getting started page&lt;/a&gt;. To complete the demo, please ensure to have a cluster with at least 16GB of memory.&lt;/span&gt;&lt;/div&gt;   &lt;div&gt;&lt;span&gt;After you install and log into your own cluster, or log into a managed cluster in the cloud, create a project with the following command:&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;pre&gt; &lt;code&gt;$ odo create project mongodb-restapi ✓ Project "mongodb-restapi" is ready for use ✓ New project created and now using project: mongodb-restapi&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Step 3: Install the Percona Distribution for MongoDB Operator&lt;/h2&gt; &lt;p&gt;We are not installing from &lt;a href="https://operatorhub.io"&gt;OperatorHub&lt;/a&gt; because the installation should be done to our specific &lt;code&gt;mongodb-restapi&lt;/code&gt; OpenShift namespace.&lt;/p&gt; &lt;p&gt;Follow these two steps:&lt;/p&gt; &lt;ol&gt;&lt;li&gt; &lt;p&gt;Install the Percona Distribution for MongoDB Operator:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;$ oc create -f https://raw.githubusercontent.com/redhat-developer/openshift-app-services-demos/main/samples/sbo/restapi-mongodb-odo/operators/mongodb-percona-distribution.yaml subscription.operators.coreos.com/percona-server-mongodb-operator created operatorgroup.operators.coreos.com/operatorgroup created&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt;Verify that you have successfully installed the Percona Distribution for MongoDB Operator. Figure 6 shows the output. &lt;pre&gt; &lt;code&gt;$ oc get csv -n mongodb-restapi NAME DISPLAY VERSION REPLACES PHASE percona-server-mongodb-operator.v1 Percona Distribution for MongoDB Operator 1.13.0 Succeeded&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;/ol&gt;&lt;h2&gt;Step 4: Install the Service Binding Operator&lt;/h2&gt; &lt;p&gt;The Service Binding Operator is always installed in all namespaces. Here, we are not installing from the OperatorHub because we must install the Operator in a particular namespace named &lt;code&gt;openshift-operators&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The following two steps will complete the process:&lt;/p&gt; &lt;ol&gt;&lt;li&gt; &lt;p&gt;Install the Service Binding Operator:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;$ oc create -f https://raw.githubusercontent.com/redhat-developer/openshift-app-services-demos/main/samples/sbo/restapi-mongodb-odo/operators/servicebinding-operator.yaml subscription.operators.coreos.com/my-service-binding-operator created &lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Verify that the Service Binding Operator is successfully installed in your namespace:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;$ oc get csv -n mongodb-restapi NAME DISPLAY VERSION REPLACES PHASE percona-server-mongodb-operator.v1 Percona Distribution for MongoDB Operator 1.13.0 Succeeded service-binding-operator.v1.3.0 Service Binding Operator 1.3.0 service-binding-operator.v1.2.0 Succeeded&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;/ol&gt;&lt;h2&gt;Summary&lt;/h2&gt; &lt;p&gt;The installation and setup are now complete. In the &lt;a href="https://developers.redhat.com/articles/2022/08/11/how-install-and-bind-mongodb-and-rest-application"&gt;next article&lt;/a&gt;, you will clone the application and create a database component for it. If you have questions, please comment below. We welcome your feedback.&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/11/10/set-openshift-cluster-deploy-application-odo-cli" title="Set up an OpenShift cluster to deploy an application in odo CLI"&gt;Set up an OpenShift cluster to deploy an application in odo CLI&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Francesco Ilario</dc:creator><dc:date>2022-11-10T07:00:00Z</dc:date></entry><entry><title>Starting Quarkus 3</title><link rel="alternate" href="&#xA;                https://quarkus.io/blog/road-to-quarkus-3/&#xA;            " /><author><name>Max Rydahl Andersen (https://twitter.com/maxandersen)</name></author><id>https://quarkus.io/blog/road-to-quarkus-3/</id><updated>2022-11-10T00:00:00Z</updated><published>2022-11-10T00:00:00Z</published><summary type="html">Quarkus 3 will continue the tradition of propelling Java development forward by moving fast and keep bringing a cutting-edge user experience with the latest technologies. We are happy to make a first Quarkus 3 Alpha available for users to try out and extension writers to integrate with so that we...</summary><dc:creator>Max Rydahl Andersen (https://twitter.com/maxandersen)</dc:creator><dc:date>2022-11-10T00:00:00Z</dc:date></entry><entry><title>How static application security testing improves software security</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/11/09/how-static-application-security-testing-improves-software-security" /><author><name>Florencio Cano Gabarda</name></author><id>bd669d29-5afa-4243-9978-b13072135c19</id><updated>2022-11-09T07:00:00Z</updated><published>2022-11-09T07:00:00Z</published><summary type="html">&lt;p&gt;Static application security testing (SAST) is one of the most effective techniques to improve application security. The term covers a variety of testing techniques that analyze an application's source, bytecode, or binary code for security vulnerabilities. Typically, developers complete this analysis during the software development lifecycle of an &lt;a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-218.pdf"&gt;application&lt;/a&gt;. Many SAST tools are mature, and the techniques have become central to &lt;a href="https://developers.redhat.com/topics/secure-coding"&gt;secure coding&lt;/a&gt;. Source code is the most common target of SAST, but you can also utilize SAST on bytecode and binary code.&lt;/p&gt; &lt;p&gt;Binary scanning analyzes the binary itself or the result of disassembling or decompiling it. Scanning binaries can add a benefit, unlike source code scanning, which identifies vulnerabilities created by the compiler. On the other hand, the reports from scanning binaries have many more false positives in some cases.&lt;/p&gt; &lt;p&gt;In general, SAST tools may generate many false positives and require tuning. The &lt;a href="https://redhatproductsecurity.github.io/secure-development-guide/code-scanning/sast.html"&gt;Red Hat Security Guide&lt;/a&gt; provides an overview of SAST.&lt;/p&gt; &lt;h2&gt;Why is SAST important?&lt;/h2&gt; &lt;p&gt;As SAST tools analyze source code, they can point to the exact location of problematic statements. Dynamic application security testing (&lt;a href="https://www.redhat.com/en/blog/automated-dynamic-application-security-testing-enhancing-development-security-rapidast"&gt;DAST&lt;/a&gt;) and other runtime testing can indicate an existing problem, but they might not indicate where the it is.&lt;/p&gt; &lt;p&gt;Additionally, SAST is a recommendation and requirement by many regulations, standards, and frameworks, including the &lt;a href="https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/"&gt;US Executive Order on Improving the Nation's Cybersecurity&lt;/a&gt;, NIST's &lt;a href="https://csrc.nist.gov/publications/detail/sp/800-218/final"&gt;Secure Software Development Framework&lt;/a&gt; (SSDF), and NIST's &lt;a href="https://csrc.nist.gov/publications/detail/sp/800-53/rev-5/final"&gt;Security and Privacy Controls for Information Systems and Organizations&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;How SAST works&lt;/h2&gt; &lt;p&gt;SAST tools parse the source code, bytecode, or binary code to identify security vulnerabilities. The following sections describe two popular techniques that search for patterns and taint analysis.&lt;/p&gt; &lt;h3&gt;How SAST tools search patterns&lt;/h3&gt; &lt;p&gt;A SAST tool frequently looks for patterns and has a catalog of possibly dangerous code constructs. Many tools support ad-hoc patterns too. These tools report a vulnerability whenever it finds a dangerous pattern in the source code. For example, to identify an SQL injection vulnerability in Java, the SAST scanner would search for something like the following:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;String query = "SELECT username FROM users WHERE userid = " + request.getParameter("userid");&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Of course, the tool needs to do the scan generically, so the patterns are generalized versions of code fragments. For example, a tool may scan for a pattern like the following, where &lt;code&gt;$COLUMN&lt;/code&gt;, &lt;code&gt;$TABLE&lt;/code&gt;, &lt;code&gt;$ATTRIBUTE&lt;/code&gt;, and the arguments to &lt;code&gt;getParameter&lt;/code&gt; can be anything:&lt;/p&gt; &lt;pre&gt; &lt;code class="java"&gt;String query = "SELECT $COLUMN FROM $TABLE WHERE $ATTRIBUTE = " + request.getParameter(...);&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This technique, unfortunately, generates many false positives.&lt;/p&gt; &lt;h3&gt;How Taint analysis works&lt;/h3&gt; &lt;p&gt;Taint analysis finds data that comes into the program from untrusted sources, such as user input, and marks that data as tainted. Tainted data is considered dangerous to use. Then, the tool follows this tainted data in the code to see whether any known cleaning function cleans it. The tool reports a security vulnerability if tainted data is passed as a parameter to a dangerous function (a sink) before cleaning.&lt;/p&gt; &lt;p&gt;Tainted analysis techniques report fewer false positives than pattern-based rules, but still may report too many false positives if the SAST scanner is not tuned. When tuning, you disallow rules that generate too many false positives and specify cleaning functions. This analysis is not a trivial effort.&lt;/p&gt; &lt;h2&gt;Other types of SAST&lt;/h2&gt; &lt;p&gt;Some people include Software Composition Analysis (SCA) and hardcoded secrets scanning in the concept of SAST. SCA identifies dependencies used by a code base and their versions. Then various vulnerability databases are consulted to determine whether these dependencies have known vulnerabilities.&lt;/p&gt; &lt;p&gt;Hardcoded secrets scanning identifies whether the source code contains secrets such as passwords, API keys, or private keys. Good security practices recommend storing secrets separately from source code, such as environment variables or a secrets management solution.&lt;/p&gt; &lt;h2&gt;The SAST workflow&lt;/h2&gt; &lt;p&gt;You should execute SAST tools as much to the left (at early stages) as possible in the development lifecycle of an application. Developers should build these tools into their integrated development environment (IDE) if possible. That way, they can see potential issues in the source code and fix them as the developers code.&lt;/p&gt; &lt;p&gt;Another place to execute SAST tools is when a developer creates a pull or merge request. If the ruleset used by the tool is mature enough, you should add the findings as comments to the commit and block the pull request until you fix the vulnerabilities.&lt;/p&gt; &lt;p&gt;It is challenging to completely eliminate false positives in the real world. So organizations could establish a threshold whereby a pull request is blocked only by matches made by mature or high-severity rules.&lt;/p&gt; &lt;p&gt;It is more manageable to enable only a few rules when initiating a SAST program so that you can develop as many findings and false positives as you can handle. If you enable all the rules from the beginning, you will have so many false positives that you may give up executing the SAST tool or ignore the findings.&lt;/p&gt; &lt;h2&gt;The languages SAST tools support&lt;/h2&gt; &lt;p&gt;Some SAST tools support multiple languages, whereas others focus on only one, such as &lt;a href="https://github.com/securego/gosec"&gt;gosec&lt;/a&gt; for Go or &lt;a href="https://engineering.fb.com/2020/08/07/security/pysa/"&gt;Pysa&lt;/a&gt; for Python. The tools dedicated to a single language usually implement more specific rules.&lt;/p&gt; &lt;p&gt;Considering multi-language open source SAST tools, we would like to highlight &lt;a href="https://github.com/returntocorp/semgrep"&gt;Semgrep&lt;/a&gt; and &lt;a href="https://github.com/joernio/joern"&gt;Joern&lt;/a&gt;. Both tools are designed to integrate easily into &lt;a href="https://developers.redhat.com/topics/ci-cd"&gt;continuous integration/continuous delivery&lt;/a&gt; (CI/CD) pipelines.&lt;/p&gt; &lt;h2&gt;Static application security testing is a worthwhile investment&lt;/h2&gt; &lt;p&gt;Static application security testing (SAST) is an excellent technique for identifying security vulnerabilities in applications, but a significant effort is required to tune SAST tools to make them more usable. The investment in developing a successful SAST program should not be underestimated. If the program is implemented properly, the software's security improves significantly.&lt;/p&gt; &lt;p&gt;You can find an extensive list of SAST tools on &lt;a href="https://github.com/analysis-tools-dev/static-analysis"&gt;GitHub&lt;/a&gt;, including a &lt;a href="https://github.com/analysis-tools-dev/static-analysis#binary"&gt;section on binary code&lt;/a&gt; scanners. The NIST page on &lt;a href="https://www.nist.gov/itl/ssd/software-quality-group/binary-code-scanners"&gt;binary code scanners&lt;/a&gt; also contains a SAST tools list.&lt;/p&gt; &lt;p&gt;We welcome your questions and feedback in the comments section below.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/11/09/how-static-application-security-testing-improves-software-security" title="How static application security testing improves software security"&gt;How static application security testing improves software security&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Florencio Cano Gabarda</dc:creator><dc:date>2022-11-09T07:00:00Z</dc:date></entry><entry><title>Quarkus 2.14.0.Final released - Jandex 3, new Redis commands, caching annotations for Infinispan</title><link rel="alternate" href="&#xA;                https://quarkus.io/blog/quarkus-2-14-0-final-released/&#xA;            " /><author><name>Guillaume Smet (https://twitter.com/gsmet_)</name></author><id>https://quarkus.io/blog/quarkus-2-14-0-final-released/</id><updated>2022-11-09T00:00:00Z</updated><published>2022-11-09T00:00:00Z</published><summary type="html">Today, we released Quarkus 2.14.0.Final with a lot of new features and small improvements all over the place: Upgrade to Jandex 3 Include quarkus-opentelemetry-exporter-otlp into quarkus-opentelemetry Additional Redis commands RESTEasy Reactive: multipart form improvements Support for caching annotations for Infinispan Improved Kotlin support for Hibernate Reactive with Panache Support embedding...</summary><dc:creator>Guillaume Smet (https://twitter.com/gsmet_)</dc:creator><dc:date>2022-11-09T00:00:00Z</dc:date></entry></feed>
